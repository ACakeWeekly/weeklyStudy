在JS中，垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要时，就应该予以释放，以让出内存。但如果操作不当，JS 中依然会出现内存溢出的情况

## 一、为什么会有垃圾回收
由于字符串、对象和数组没有固定大小，只有当它们的大小已知时，才能对他们进行动态的存储分配。JS 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JS的解释器将会消耗完系统中所有可用的内存，造成系统崩溃

在 `C`, `C++` 中，开发人员可以直接控制内存的申请与回收，而在 `JS` 中开发人员无需关心这个问题，所需内存的非配以及无用内存的回收完全实现了自动化管理

### 1.1、原理
垃圾回收的的原理是：
> **找出那些不再继续使用的变量，然后释放其占用的内存**

垃圾回收器会按照固定的时间间隔，周期性执行这一操作。关于如何找出 **“不再使用的变量”**，有下面俩种策略

## 二、垃圾回收策略

### 2.1、引用计数
> 跟踪记录每个 **值** 被引用的次数

引用计数是一种不太常见的垃圾收集策略，最早应用于 `Netscape Navigator` 3.0 版本浏览器中。

```js
let obj1 = {a: 10} // 引用类型值 A {a: 10}, 赋值给变量 obj1, A 引用次数为 1
let obj2 = obj1 // 同一个值又赋值给变量 obj2, A 引用次数加 1， 为 2

obj2 = {b: 20} // 变量 obj2 重新取得新值， A 引用次数减 1， 为 1
obj1 = null // 变量 obj1 为 null， A 引用次数减 1， 为 0
```
👆上面Demo中，最终 `A` 这个值的引用次数为 0，则说明没有办法再访问这个值了，因此可以将其占用的内存空间回收回来。
这样，当垃圾收集器下次再运行时，它会释放那些引用次数为零的 **值** 所占用的内存

引用计数策略最大的问题在于 **`循环引用`**
> 循环引用：对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用

```js
function problem () {
    let objA = {age: 10} // 引用类型值 M {age: 10}
    let objB = {age: 20} // 引用类型值 N {age: 20}

    objA.aaa = objB
    objB.bbb = objA
}
```
👆上面例子中，`objA`和`objB`通过各自的属性相互引用，对于引用类型值 `M` 和 `N` 而言，它们的引用次数都是 2。

在采用引用计数策略的实现中，当函数执行完毕后，objA 和 objB 还将继续存在，所以引用类型值 `M` 和 `N` 的引用次数永远不可能为 0，当函数多次调研，会造成大量内存不能回收。该缺陷会在接下来的策略中解决

### 2.2、标记清除
**标记清除**(mark-and-sweep)是JS中最常见的垃圾收集策略。从 2012 年起，除去低版本IE浏览器,所有浏览器都采用该策略

- `进入环境`：当变量进入环境（例如：在函数内部声明一个变量），将其变量标记为“进入环境”
- `离开环境`：变量离开环境，将其标记成“离开环境”

为了找到 “不再使用” 的变量，标记清除策略需要经过一些3个步骤：
- **`根节点`**：一般来说，根是代码中引用的全局变量。例如，在 JavaScript 中，可以充当根节点的全局变量是“window”对象。Node.js 中的全局对象被称为“global”。完整的根节点列表由垃圾收集器构建
- 从根节点开始遍历所有可访问对象，然后`检查他们的子节点并且把他们标记为活跃的`（意思是他们不是垃圾）。任何根节点不能访问的变量将被标记为垃圾

- 最后，`垃圾收集器释放所有未被标记为活跃的内存块，并将这些内存返回给操作系统`

  ![mark-and-sweep](https://user-gold-cdn.xitu.io/2019/3/31/169d41fe9e180e5d?imageslim)

对于引用计数中的循环引用，在函数执行完毕后，引用类型值 M，N 不再被全局对象中的变量引用。因此，垃圾收集器会认为它们不可访问。

## 三、性能问题

如何找到“不再使用”的变量已经知道了，但垃圾收集器何时去找，还需进一步了解。

垃圾收集器是周期性运行的，确定垃圾收集间隔是一个非常重要的问题。

- **静态**：`IE6` 中垃圾回收是根据内存分配量运行的，当环境中存在 256 个变量、4096 个对象、64 KB的字符串中任意一种情况的时候就会触发垃圾回收器工作。如果程序中存在大量变量，并且在其生命周期中需要保留一段时间，垃圾回收器就不得不频繁工作，所以在 `IE7` 中采用下面工作方式

- **动态**：触发垃圾收集的变量分配、字面量或数组元素的临界值都被调整成 动态修正。 一开始：各项临界值在初识时与IE6相等，如果垃圾收集器某次回收的内存分配量低于 `15%`，则变量、字面量或数组元素的临界值就会加倍。如果某次回收了 `85%` 的内存分配量，则将各种临界值重置回默认值


## 四、内存管理

虽然在 JS 中，开发人员无需手动操作内存，但还是需要对内存管理有所了解，有时，自动内存管理也存在一些问题，开发人员需要了解它们，以便可以正确处理。

出于安全考虑，分配给浏览器的可用内存数量通常比分配给桌面应用程序的少，目的是防止运行 JS 的网页耗尽全部系统的内存导致系统崩溃。

页面想要获得更好的性能，需要确保占用最少的内存，一旦数据不再有用，最好通过将其值设置成`null` 来释放其引用。

> **内存泄漏**：`应用程序过去使用，但不再需要的尚未返回到操作系统或可用内存池的内存片段`

### 4.1、 JS 中常见的 4 中内存泄漏

- **意外的全局变量**
  ```js
  function fun () {
    bar =  "this is a hidden global variable";  // bar将泄漏到全局
  }
  ```
  `bar`没被声明,会变成一个全局变量,在页面关闭之前不会被释放
  
  **解决办法**: 启用严格模式 `use strict`

- **未清除的定时器 ⏲️ 或回调函数**

  ```js
  var someResource = getData()
  setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        // 处理 node 和 someResource
        node.innerHTML = JSON.stringify(someResource));
    }
  }, 1000);
  ``` 
  当ID为 `node` 的元素从DOM中移除之后，该定时器仍然存在，同时回调函数中保留了对 `someResource` 的引用，定时器外面的someResource也不会被释放。

  **解决办法**: 定时器完成工作的时候，手动清除定时器

- **闭包**

  闭包的特性可以让我们在外部作用域访问内部作用域中的变量
  ```js
  function foo() {
    let local = 123;
    return function() {
        return local;
    }
  }
  let bar = foo();
  console.log(bar()); // -> 123

  bar = null
  ```
  一般情况下，当`foo`函数执行完毕后，它的作用域会被销毁，但是由于存在变量引用其返回的匿名函数，导致作用域无法得到释放，也就导致`local`变量无法回收，只有当我们取消掉对匿名函数的引用才会进入垃圾回收阶段

- **DOM的过度引用**

  日常开发中，为了避免频繁访问同一个 DOM 元素时，好的做法是通过一个变量将 DOM 元素存储在内存中
  ```js
  let button = document.getElementById('button');
  ```
  当删除这个按钮时：
  ```js
  document.body.removeChild(document.getElementById('button'));
  ```
  看似DOM元素被删除，但实际上仍然被 `button` 这个变量所引用。所以在内存中，这个DOM 元素是没法被回收的。所以在使用结束后，还需要将 `button` 设成 `null`

  ## 五、总结

  ### 5.1、参考连接

  - [How JavaScript works: memory management + how to handle 4 common memory leaks](https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec)

  - JS高程3
